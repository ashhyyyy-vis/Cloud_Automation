name: Deploy (Platform)

on:
  workflow_dispatch:

jobs:

  ####################################################################
  #                            PREPARE                               #
  ####################################################################
  prepare:
    runs-on: ubuntu-latest
    outputs:
      apps-json: ${{ steps.read.outputs.apps }}
      app-ids: ${{ steps.ids.outputs.ids }}
      apps-b64: ${{ steps.ids.outputs.apps_b64 }}

    steps:
      - uses: actions/checkout@v4

      - name: Install yq
        run: |
          sudo wget -qO /usr/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/bin/yq

      - name: Read backend from deployment-config.yaml
        id: read
        shell: bash
        run: |
          if [ ! -f deployment-config.yaml ]; then
            echo "ERROR: deployment-config.yaml not found"
            exit 1
          fi

          # Extract YAML → JSON
          APPS=$(yq -o=json '.backend' deployment-config.yaml)

          echo "apps=$APPS" >> $GITHUB_OUTPUT

      - name: Extract backend app IDs
        id: ids
        shell: bash
        run: |
          RAW='${{ steps.read.outputs.apps }}'

          RAW_B64=$(printf "%s" "$RAW" | base64 -w0)
          echo "apps_b64=$RAW_B64" >> $GITHUB_OUTPUT

          IDS=$(echo "$RAW" | yq -o=json 'keys')
          echo "ids=$IDS" >> $GITHUB_OUTPUT


  ####################################################################
  #                            DEPLOY                                #
  ####################################################################
  deploy:
    needs: prepare
    runs-on: ubuntu-latest
    strategy:
      matrix:
        app-id: ${{ fromJson(needs.prepare.outputs.app-ids) }}
      fail-fast: false

    steps:
      - uses: actions/checkout@v4

      - name: Install yq
        run: |
          sudo wget -qO /usr/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/bin/yq

      - name: Parse backend app config
        id: parse
        shell: bash
        run: |
          APP_KEY="${{ matrix.app-id }}"
          APP_KEY=$(echo "$APP_KEY" | sed 's/"//g')

          # Decode backend JSON
          APPS_JSON=$(echo "${{ needs.prepare.outputs.apps-b64 }}" | base64 -d)

          # Extract single backend module as JSON
          APP_JSON=$(printf "%s" "$APPS_JSON" | yq -o=json ".\"$APP_KEY\"")

          echo "=== Parsed App Config ==="
          echo "$APP_JSON" | yq
          echo "========================="

          echo "image_repo=$(echo "$APP_JSON" | yq -r '.image_repo')" >> $GITHUB_OUTPUT
          echo "launch_template_id=$(echo "$APP_JSON" | yq -r '.launch_template_id')" >> $GITHUB_OUTPUT
          echo "asg_name=$(echo "$APP_JSON" | yq -r '.asg_name')" >> $GITHUB_OUTPUT
          echo "region=$(echo "$APP_JSON" | yq -r '.region')" >> $GITHUB_OUTPUT
          echo "port=$(echo "$APP_JSON" | yq -r '.port')" >> $GITHUB_OUTPUT
          echo "health_path=$(echo "$APP_JSON" | yq -r '.health_path')" >> $GITHUB_OUTPUT
          echo "instance_warmup=$(echo "$APP_JSON" | yq -r '.instance_warmup')" >> $GITHUB_OUTPUT
          echo "min_healthy_percent=$(echo "$APP_JSON" | yq -r '.min_healthy_percent')" >> $GITHUB_OUTPUT
          echo "user_data_template=$(echo "$APP_JSON" | yq -r '.user_data_template')" >> $GITHUB_OUTPUT
          echo "ssm_param_name=$(echo "$APP_JSON" | yq -r '.ssm_param_name')" >> $GITHUB_OUTPUT

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ steps.parse.outputs.region }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: gha-deploy

      - name: Export deployment vars
        id: vars
        run: |
          echo "image_tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "image_repo=${{ steps.parse.outputs.image_repo }}" >> $GITHUB_OUTPUT
          echo "lt_id=${{ steps.parse.outputs.launch_template_id }}" >> $GITHUB_OUTPUT
          echo "asg_name=${{ steps.parse.outputs.asg_name }}" >> $GITHUB_OUTPUT
          echo "ud_template=${{ steps.parse.outputs.user_data_template }}" >> $GITHUB_OUTPUT
          echo "ssm_param=${{ steps.parse.outputs.ssm_param_name }}" >> $GITHUB_OUTPUT
          echo "warmup=${{ steps.parse.outputs.instance_warmup }}" >> $GITHUB_OUTPUT
          echo "minheal=${{ steps.parse.outputs.min_healthy_percent }}" >> $GITHUB_OUTPUT

      - name: Write image tag to SSM (SSM mode)
        if: ${{ steps.vars.outputs.ud_template == 'ssm' }}
        run: |
          aws ssm put-parameter \
            --name "${{ steps.vars.outputs.ssm_param }}" \
            --value "${{ steps.vars.outputs.image_repo }}:${{ steps.vars.outputs.image_tag }}" \
            --type String \
            --overwrite

      - name: Create new Launch Template version (UserData mode)
        if: ${{ steps.vars.outputs.ud_template != 'ssm' }}
        id: newlt
        run: |
          IMAGE_REPO="${{ steps.vars.outputs.image_repo }}"
          IMAGE_TAG="${{ steps.vars.outputs.image_tag }}"
          PORT="${{ steps.parse.outputs.port }}"

          echo "#!/bin/bash" > user-data.sh
          echo "set -e" >> user-data.sh
          echo "IMAGE_FULL=\"$IMAGE_REPO:$IMAGE_TAG\"" >> user-data.sh
          echo "docker pull \$IMAGE_FULL || true" >> user-data.sh
          echo "docker stop myapp || true" >> user-data.sh
          echo "docker rm myapp || true" >> user-data.sh
          echo "docker run -d --name myapp --restart always -p $PORT:$PORT \$IMAGE_FULL" >> user-data.sh

          USERDATA_B64=$(base64 -w 0 user-data.sh)

          NEW_VERSION=$(aws ec2 create-launch-template-version \
            --launch-template-id "${{ steps.vars.outputs.lt_id }}" \
            --launch-template-data "{\"UserData\":\"$USERDATA_B64\"}" \
            --version-description "deploy-$IMAGE_TAG" \
            --query 'LaunchTemplateVersion.VersionNumber' \
            --output text)

          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Update Auto Scaling Group (if LT updated)
        run: |
          if [ "${{ steps.vars.outputs.ud_template }}" = "ssm" ]; then
            echo "SSM mode, skipping LT update."
            exit 0
          fi

          aws autoscaling update-auto-scaling-group \
            --auto-scaling-group-name "${{ steps.vars.outputs.asg_name }}" \
            --launch-template "LaunchTemplateId=${{ steps.vars.outputs.lt_id }},Version=${{ steps.newlt.outputs.new_version }}"

      - name: Start instance refresh
        id: refresh
        run: |
          ASG="${{ steps.vars.outputs.asg_name }}"

          REFRESH_ID=$(aws autoscaling start-instance-refresh \
            --auto-scaling-group-name "$ASG" \
            --strategy Rolling \
            --preferences "{\"MinHealthyPercentage\":${{ steps.vars.outputs.minheal }},\"InstanceWarmup\":${{ steps.vars.outputs.warmup }}}" \
            --query 'InstanceRefreshId' \
            --output text)

          echo "refresh_id=$REFRESH_ID" >> $GITHUB_OUTPUT

      - name: Wait for refresh to complete
        run: |
          ASG="${{ steps.vars.outputs.asg_name }}"
          REF="${{ steps.refresh.outputs.refresh_id }}"

          while true; do
            STATUS=$(aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name "$ASG" \
              --instance-refresh-ids "$REF" \
              --query 'InstanceRefreshes[0].Status' \
              --output text)

            echo "Status: $STATUS"

            if [[ "$STATUS" == "Successful" ]]; then
              echo "Deployment completed successfully."
              break
            fi

            if [[ "$STATUS" == "Failed" || "$STATUS" == "Cancelled" ]]; then
              echo "Deployment failed."
              exit 1
            fi

            sleep 20
          done

      - name: Smoke test
        run: |
          echo "Smoke test placeholder — integrate with ALB health check."
